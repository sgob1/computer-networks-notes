\documentclass[a4paper, 12pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{charter}
\usepackage[libertine]{newtxmath}
\usepackage{graphicx}
\usepackage[pdfa]{hyperref}
\usepackage{color}
\usepackage{setspace}
\usepackage{parskip}
\usepackage[a4paper, inner=0.5cm, outer=0.5cm, lmargin=3.5cm, rmargin=3.5cm,
tmargin=1.8cm, bmargin=2.1cm]{geometry}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0.1,0.5,0.1}
\definecolor{greengray}{rgb}{0.32,0.57,0.32}
\definecolor{orange}{rgb}{0.96,0.42,0}
\definecolor{lightblue}{rgb}{0,0.28,0.95}
\definecolor{background}{rgb}{0.995,0.995,0.995}
\lstset {
	frame=tb,
	language=java,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	backgroundcolor=\color{background},
	numberstyle=\tiny\color{drkgeen},
	keywordstyle=\color{lightblue},
	commentstyle=\color{greengray},
	stringstyle=\color{orange},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
\setlength{\parindent}{0pt}

\begin{document}
\setstretch{1.25}
\title{Computer Networks 2 and Introduction to Cybersecurity}
\author{Marco Sgobino}
\maketitle
\tableofcontents

\part{Low-Level Network Protocols}

\chapter{TCP}

\section{Brief recap of TCP}
TCP is a procotol that has the following properties,

\begin{itemize}
	\item allows \emph{connection between processes};
	\item is \emph{connection-oriented};
	\item is \emph{reliable};
	\item is \emph{byte-oriented}.
\end{itemize}

The logical structure is the following one. There are client and server. The
client first authenticates to the server, after that the server opens the
connection and client executes send-receive loop. Both server and client create
a \emph{socket} $s$, and the client connect $s$ to IP-srv, port-srv. The
communication takes place on $s$ by means of application protocol. It is
\emph{reliable}: no losses, no packet loss, packet arrive in the same order as
they are sent.

A very simplified pseudo-code for TCP is as following,

\begin{verbatim} int s; s := socket(...); connect(s, IP-srv, port-srv,...); ...
send (s, msgl, ...); ... msg2 := receive(s,...); ... \end{verbatim}

The logical structure at server side is quite different. A server creates
socket $s1$, chooses a port number to bind to that socket, then it declares
willingness to accept connections on $s1$, and finally it awaits for connection
requests on $s1$. Server remains on \emph{sleep} until a connection is
requested.

\begin{verbatim} s1 := socket(...); bind(s1, portsrvm ...); listen(s1,...); s2
:= accept(s1,...); // another socket ... msg1 := receive(s2,...); ...
send(s2,msg2,...); ... \end{verbatim}

In TCP, communication is \emph{bidirectional}, with a pattern that depends on
the application protocol.

The send-receive patterns depend on the application itself \--- browser
send-receive sequences are very different from, let's say, an e-mail client
send-receive sequence.

\subsection{TCP Implementation}

IP operates between \emph{nodes}. It is \emph{connectionless},
\textbf{unreliable}, and is \emph{message-oriented}. The Maximum Transmission
Unit size of an IP packet is $MTU = 64KB$. TCP lies on top of IP: to overcome
the unreliable aspect of IP, countermeasures should be adopted.

TCP layers communicate between themselves in terms of \emph{segments}. A
segment is a \emph{message between TCP layers}, and contains a \emph{TCP
header} and \--- eventually \--- data \emph{payload}. Payload can either be $0$
byte or carry some information useful for application layers. An important
property is that \emph{it must be small enough to fit in a single IP packet},
hence IP header + TCP segment size should be no greater than $64KB$.

A segment is thus composed by a IP header, whose payload is a TCP segment. The
TCP segment is composed by a TCP header, followed by eventual application data.
Usually, IP header size is usually $20$ bytes, as well as TCP header that is
$20$ bytes. The IP datagram can be greater up to $64KB$, with the first $40,50$
bytes reserved to headers.

Segments can carry portions of data (for instance, in a video stream many
segments should be sent to client in order to carry enough information and let
application layer reconstruct the video correctly).

In application layer, one application message could correspond to \emph{many
segments} in TCP layer, in \textbf{both} directions. In fact, at TCP level
multiple segments are usually required in order to send a single
application-level message.

Each TCP layer represents a connection as (<id>, <state>). The <id> is the
<IP-local, port-local, IP-remote, port-remote>, while the <state> refers to the
state of the TCP connection. Conceptually there is a single table storing both
<id> along with connection <state>.

IP addresses are extracted from the IP header, while port numbers are extracted
from TCP header. Packets are thus sorted accordingly. The connection <state>
includes information on the \emph{Maximum Segment Size} (MSS), which is the
maximum size of the \emph{data part} of a segment that the other part is
willing to achieve. The MSS is negotiated upon connection opening. This value
is, in practice, identical in both direction and is not arbitrary. In most
cases, there are only $2$ possible values for historical reasons:

\begin{itemize}
	\item on different networks (through internet), MSS is $536$ bytes (MTU=576),
		that is the maximum segment size that can fit in the smallest
		possible packet;
	\item on same network (ethernet), MSS is $1460$ bytes (MTU=1500), which
		corresponds to ethernet MTU minus the IP header and TCP header.
\end{itemize}

The core idea is that each segment must be sufficiently small to fit in one
packet along the full path, in order to prevent fragmentation.

TODO Add figure that recaps IP header + TCP header.

\part{Network Tools}

\chapter{Wireshark}

\emph{Wireshark} is a free and open-source tool for \emph{recording} and
\emph{analyzing} network messages. Recording takes place in a local interface,
while analysis can be done anywhere by loading saved sessions in a file.
Wireshark is useful for analysis, troubleshooting and understanding of a
network's behavior.

\section{Network analysis with pre-captured session}



\end{document}

